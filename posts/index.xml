<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on devflow</title>
    <link>https://devflow.github.io/posts/</link>
    <description>Recent content in Posts on devflow</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 09 Apr 2020 00:03:43 +0900</lastBuildDate>
    
	<atom:link href="https://devflow.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>i3wm를 알아보자</title>
      <link>https://devflow.github.io/posts/6/</link>
      <pubDate>Thu, 09 Apr 2020 00:03:43 +0900</pubDate>
      
      <guid>https://devflow.github.io/posts/6/</guid>
      <description>i3에 대해서 기존 DE(Desktop Environment) 사용자의 시선에서 알아보도록하자.  i3? i3은 GNU/Linux, BSD 운영체제를 위한 Tiling window manager 중 하나임.
Tiling window manager? 흔하게 접할 수 있는 TWM에는 윈도우즈(Windows)의 타일링 시스템이 있다. 시작+방향키 단축키나, 창을 한쪽으로 드래그해서 각 윈도우(창)들을 겹치지 않게 정렬을 해본 기억이 있을 것이다. 이러한 메커니즘으로 창들을 정렬할 수 있게 하는 프로그램.
 X11의 twm(Tab window manager)와는 다르다.  왜 i3 인가? i3는 TWM중에서 사용이 제일 쉽다고 느끼고 무엇보다도 문서화가 아주 잘 되어 있고 사용자들도 많으므로 사용중 문제가 생겼거나, 궁금한 점은 다양한 커뮤니티를 통해 순식간에 해결할 수 있다는 점.</description>
    </item>
    
    <item>
      <title>OpenCV를 이용해서 UI 오브젝트 검출</title>
      <link>https://devflow.github.io/posts/5/</link>
      <pubDate>Sat, 04 Apr 2020 15:00:07 +0900</pubDate>
      
      <guid>https://devflow.github.io/posts/5/</guid>
      <description>개발 환경은 아래와 같다.
 OpenCV 4.2 (Built for Android with NONFREE) Android 10  내가 검출하고자 하는 데이터는 실제(Real Object)가 아니고 안드로이드의 Display에서 특정 UI 컴포넌트를 검출하는 작업이 필요했다.
먼저 시도한 방법은 OpenCV의 TemplateMatching.
하지만 여러 디바이스 환경에서의 UI 컴포넌트의 사이즈와 변형(반응형 디자인)으로 인해 TemplateMatching의 특성상 검출하려는 오브젝트의 크기가 검출 대상 소스에서의 크기는 같아야 하고 Multi-scaling의 방식이나 MatPyramid 등 다양한 scale-case 를 반영해도 변형된 데이터에서는 검출이 힘들었다.
그래서 시도해본 것은 SURF, SIFT 그리고 ORB.</description>
    </item>
    
    <item>
      <title>안드로이드 MediaProjection 을 통해서 ImageReader로 버퍼 읽을시 검은 화면</title>
      <link>https://devflow.github.io/posts/4/</link>
      <pubDate>Sat, 04 Apr 2020 14:00:07 +0900</pubDate>
      
      <guid>https://devflow.github.io/posts/4/</guid>
      <description>우선 5.0(API 21) 이상에서는 대부분~ 잘되는데 특정 환경(대부분 예뮬레이터들)에서 MediaProjection을 ImageReader로 통해서 Surface를 읽으면 아무 데이터가 없거나 NULL일 수 있다.
이는 네이티브, 예뮬 등 일부 환경에서 (물론 5.0도 이상일 수 있다!) openGLES 호환(EGL_RECORDABLE_ANDROID 값이 없는 등.. )이 좋지 않아서 발생하는 문제이다.
결론은 대상 문제가 발생하는 기기에서는 별도의 방법으로 처리해야 한다는 것&amp;hellip; 일단 구글의 비공식 테스트 앱 (grafika)를 살펴보고 구현하면 된다.
우선 grafika의 gles를 모드 임포트 해준다.
 VirtualDisplay가 사용할 수 있는 Surface를 만들어 준다.</description>
    </item>
    
    <item>
      <title>리눅스 설치 후 윈도우 UEFI 복구</title>
      <link>https://devflow.github.io/posts/3/</link>
      <pubDate>Sat, 04 Apr 2020 13:45:07 +0900</pubDate>
      
      <guid>https://devflow.github.io/posts/3/</guid>
      <description>문제 환경  윈도우(Windows 10)가 sdb 에 설치됨. 리눅스(Arch Linux, GRUB)를 sda에 설치 후, 리눅스에서 os-prober가 Windows의 진입점을 찾지 못함.  준비물  부팅가능한 Windows 설치 미디어 (USB, DVD&amp;hellip;)[1]  해결  Windows 설치 미디어로 부팅한다. 문제해결 -&amp;gt; 고급 -&amp;gt; 명령 프롬프트 diskpart list disk 입력 후 윈도우가 설치된 디스크X를 찾는다. sel disk X list vol 입력 후 EFI 파티션Y을 찾아보자. 파티션은 파일시스템 FAT32을 가지며 용량은 ~512MB 정도함. sel vol Y assign letter=T: EFI 파티션을 T:에 할당하자.</description>
    </item>
    
    <item>
      <title>두번째 테스트</title>
      <link>https://devflow.github.io/posts/2/</link>
      <pubDate>Fri, 03 Apr 2020 22:00:35 +0900</pubDate>
      
      <guid>https://devflow.github.io/posts/2/</guid>
      <description>ㅗ모몸</description>
    </item>
    
    <item>
      <title>첫 글이자 테스트 포스트</title>
      <link>https://devflow.github.io/posts/1/</link>
      <pubDate>Thu, 02 Apr 2020 22:00:35 +0900</pubDate>
      
      <guid>https://devflow.github.io/posts/1/</guid>
      <description>그래서 이게 뭐냐? 음 좀 살펴보고&amp;hellip; hello();
H3 ~ H4 😄 H5 🐒 Proxy.prototype.close = function () { var self = this; this.httpServer.close(); delete this.httpServer; if (this.httpsServer) { this.httpsServer.close(); delete this.httpsServer; delete this.wssServer; delete this.sslServers; } if (this.sslServers) { (Object.keys(this.sslServers)).forEach(function (srvName) { var server = self.sslServers[srvName].server; if (server) server.close(); delete self.sslServers[srvName]; }); } return this; }; 첫 글은 이따구로 생겨야 제맛이지.. while (d &amp;lt; end) { while (d &amp;lt; end &amp;amp;&amp;amp; (*d == &amp;#39; &amp;#39; || *d == &amp;#39;\n&amp;#39; || *d == &amp;#39;\r&amp;#39;)) ++d; const char *start = d; while (d &amp;lt; end &amp;amp;&amp;amp; *d !</description>
    </item>
    
  </channel>
</rss>